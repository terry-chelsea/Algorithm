我的解法：首先要判断两个链表是否真正的有共同的节点，因为如果两个链表有相同的节点，那么该节点后面所有的节点都是两个链表所共有的，那么我们只需要查看两个链表的结尾是否相同就可以判断他们是否有公共的节点。
找到他们有公共的节点之后再找出第一个共同的节点，假设A的长度为LA，B链表的长度为LB，子第一个共同的节点之后他们所有的节点都是共同的，所以他们的长度只差在于非共同节点的长度只差。
假设LA>LB,那么首先指向A链表的第LA-LB个节点，然后两个链表的遍历指针同时前进，如果他们两个指向了相同的节点，那么第一个相同的节点就是我们要找的节点，否则它们会同时走到null。

新的解法：定义两个指针pA和pB，分别指向链表A和链表B，然后循环得向后遍历，如果指针pA等于null了，那么就让它指向链表B的头节点，如果pB等于null了，让它指向链表A的头节点。
因为第一次某个指针到达null的时候，另一个指针还有N步到达null，那么N就是这两个链表的长度差，当第二个指针等于null的时候，另一个已经重新指向另一个头结点的指针已经在较长的链表上
走了N步，因此接下来两个继续走要么同时到达交接点，要么同时都到达null。
这种解法代码更加简洁！